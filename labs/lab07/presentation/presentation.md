---
## Front matter
lang: ru-RU
title: Презентация по лабораторной работе №7
subtitle: Информационная безопасность
author:
  - Акондзо Жордани Лади Гаэл.
institute:
  - Российский университет дружбы народов, Москва, Россия
date: 17 Октября 2024

## i18n babel
babel-lang: russian
babel-otherlangs: english

## Formatting pdf
toc: false
toc-title: Содержание
slide_level: 2
aspectratio: 169
section-titles: true
theme: metropolis
header-includes:
 - \metroset{progressbar=frametitle,sectionpage=progressbar,numbering=fraction}
 - '\makeatletter'
 - '\beamer@ignorenonframefalse'
 - '\makeatother'
---

# Информация

## Докладчик

:::::::::::::: {.columns align=center}
::: {.column width="70%"}

  * Акондзо Жордани Лади Гаэл.
  * студент 4-го курса группы НКНбд-01-21
  * 1032215649
  * Российский университет дружбы народов
  * [GitHub](https://github.com/Jordaniakondzo)

:::
::::::::::::::

# Вводная часть

## Актуальность

- Обеспечение безопасности
- Предотвращение пересечений между пользовательскими аккаунтами
- Совместный доступ к файлам

# Цель работы

* Цель данной лабораторной работы — изучение метода однократного гаммирования для шифрования и дешифрования данных.


# Теоретическое введение

* Однократное гаммирование (шифр Вернама) — это метод симметричного шифрования, при котором каждое сообщение шифруется с помощью ключа, длина которого совпадает с длиной сообщения. Шифрование и дешифрование происходит с использованием операции побитового исключающего ИЛИ (XOR) между символами ключа и открытого текста. Преимущество однократного гаммирования заключается в его абсолютной криптостойкости, если ключ используется только один раз и является абсолютно случайным.

## Материалы и методы

- Веб-сервис `GitHub` для работы с репозиториями
- Программа для виртуализации ОС `VirtualBox`
- Процессор `pandoc` для входного формата Markdown
- Результирующие форматы
	- `pdf`
	- `docx`
- Автоматизация процесса создания: `Makefile`

# Выполнение лабораторной работы

## Первый вариант программы: фиксированное сообщение для шифрования

![](image/1.png)

## КОД1:

```
import os

def generate_key(length):
    # Генерирует случайный ключ заданной длины
    return os.urandom(length)

def xor_operation(data, key):
    # Применяет операцию XOR между данными и ключом
    return bytes([a ^ b for a, b in zip(data, key)])

# Открытый текст
plaintext = "С Новым Годом, друзья!"

# Конвертируем текст в байты
plaintext_bytes = plaintext.encode('utf-8')

# Генерируем ключ той же длины, что и открытый текст
key = generate_key(len(plaintext_bytes))

# Шифруем сообщение с помощью операции XOR
ciphertext = xor_operation(plaintext_bytes, key)

# Выводим зашифрованный текст в шестнадцатеричном формате
print("Зашифрованный текст (hex):", ciphertext.hex())

# Дешифруем сообщение, применяя XOR снова с тем же ключом
decrypted = xor_operation(ciphertext, key)

# Конвертируем результат обратно в текст
decrypted_text = decrypted.decode('utf-8')

# Выводим дешифрованный текст, чтобы проверить, совпадает ли он с оригинальным сообщением
print("Дешифрованный текст:", decrypted_text)

```

## Описание работы программы:

1. Генерация ключа: Программа генерирует случайный ключ с помощью функции `os.urandom()`, который соответствует длине открытого текста.
2. Шифрование: С помощью операции XOR каждый байт открытого текста комбинируется с соответствующим байтом ключа.
3. Дешифрование: Повторное применение операции XOR с тем же ключом позволяет восстановить исходный текст.

## Результат_1:

![](image/2.png)

##  Второй вариант программы: ввод текста пользователем

![](image/3.png)

## КОД2:

```
import os

def generate_key(length):
    # Генерирует случайный ключ заданной длины
    return os.urandom(length)

def xor_operation(data, key):
    # Применяет операцию XOR между данными и ключом
    return bytes([a ^ b for a, b in zip(data, key)])

# Запрос ввода сообщения у пользователя
plaintext = input("Введите сообщение для шифрования: ")

# Конвертируем текст в байты
plaintext_bytes = plaintext.encode('utf-8')

# Генерируем ключ той же длины, что и открытый текст
key = generate_key(len(plaintext_bytes))

# Шифруем сообщение с помощью операции XOR
ciphertext = xor_operation(plaintext_bytes, key)

# Выводим зашифрованный текст в шестнадцатеричном формате
print("Зашифрованный текст (hex):", ciphertext.hex())

# Дешифруем сообщение, применяя XOR снова с тем же ключом
decrypted = xor_operation(ciphertext, key)

# Конвертируем результат обратно в текст
decrypted_text = decrypted.decode('utf-8')

# Выводим дешифрованный текст, чтобы проверить, совпадает ли он с оригинальным сообщением
print("Дешифрованный текст:", decrypted_text)

```

## Описание работы программы 2:
1. Ввод сообщения: Пользователь вводит любое сообщение, которое будет зашифровано.
2. Генерация ключа: Ключ генерируется случайным образом и имеет ту же длину, что и введённое сообщение.
3. Шифрование и дешифрование: Программа выполняет шифрование и дешифрование с помощью операции XOR.

## Результат_2:

![](image/4.png)
![](image/5.png)

# Выводы

В ходе выполнения лабораторной работы были созданы два варианта программы для однократного гаммирования. В первом случае программа демонстрировала шифрование фиксированного текста, а во втором случае пользователь мог вводить любое сообщение для шифрования. Оба варианта программы успешно продемонстрировали работу метода однократного гаммирования, а также его основное преимущество — невозможность восстановления исходного текста без знания ключа.